<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è¯­éŸ³å¯¹è¯æµ‹è¯• - ASR + AI + TTS</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin: 15px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.2em;
            margin: 10px 0;
            opacity: 0.9;
        }

        button {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            margin: 8px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .config-section {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .config-section label {
            font-weight: 600;
            color: #495057;
        }

        .config-section input {
            padding: 8px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .config-section input:focus {
            outline: none;
            border-color: #007bff;
        }

        .results-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .results-container {
                grid-template-columns: 1fr;
            }
        }

        .result-panel {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            padding: 20px;
            border-radius: 8px;
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
        }

        .result-panel h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 1.1em;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 8px;
        }

        .asr-result {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px;
            margin: 8px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .ai-reply {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            padding: 10px;
            margin: 8px 0;
            border-radius: 4px;
        }

        .audio-item {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
            padding: 10px;
            margin: 8px 0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
            text-align: center;
            transition: all 0.3s ease;
        }

        .status.connected {
            background: linear-gradient(45deg, #d4edda, #c3e6cb);
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .status.disconnected {
            background: linear-gradient(45deg, #f8d7da, #f5c6cb);
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        .status.recording {
            background: linear-gradient(45deg, #fff3cd, #ffeaa7);
            color: #856404;
            border: 2px solid #ffeaa7;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }

            100% {
                transform: scale(1);
            }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .audio-controls audio {
            max-width: 200px;
        }

        .timestamp {
            font-size: 0.8em;
            color: #6c757d;
            margin-bottom: 5px;
        }

        .clear-btn {
            background: linear-gradient(45deg, #dc3545, #c82333);
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
        }

        .clear-btn:hover {
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.4);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #dee2e6;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #007bff;
        }

        .stat-label {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>ğŸ¤– AI è¯­éŸ³å¯¹è¯æµ‹è¯•</h1>
        <p>ASR è¯­éŸ³è¯†åˆ« â†’ AI æ™ºèƒ½å›å¤ â†’ TTS è¯­éŸ³åˆæˆ</p>
    </div>

    <div class="container">
        <h3>âš™ï¸ è¿æ¥é…ç½®</h3>
        <div class="config-section">
            <label for="appIdInput">åº”ç”¨ID:</label>
            <input type="text" id="appIdInput" value="1970673379841900546" placeholder="è¾“å…¥åº”ç”¨ID">
            <label for="wsUrlInput">WebSocketåœ°å€:</label>
            <input type="text" id="wsUrlInput" value="ws://localhost:8123/api/ws/audio" placeholder="WebSocket URL">
        </div>
        <div class="config-section">
            <label for="silenceThresholdInput">é™éŸ³é˜ˆå€¼:</label>
            <input type="number" id="silenceThresholdInput" value="0.05" step="0.001" min="0" max="1" placeholder="0.05"
                style="width: 80px;">
            <label for="vadEnabledInput">å¯ç”¨è¯­éŸ³æ£€æµ‹:</label>
            <input type="checkbox" id="vadEnabledInput" checked>
            <span style="font-size: 12px; color: #666;">ï¼ˆå¯ç”¨åä¼šè‡ªåŠ¨åœæ­¢å½•éŸ³ï¼‰</span>
        </div>
        <div id="wsStatus" class="status disconnected">æœªè¿æ¥</div>
        <div class="controls">
            <button id="connectBtn" onclick="connectWebSocket()">ğŸ”— è¿æ¥æœåŠ¡</button>
            <button id="disconnectBtn" onclick="disconnectWebSocket()" disabled>âŒ æ–­å¼€è¿æ¥</button>
        </div>
    </div>

    <div class="container">
        <h3>ğŸ™ï¸ è¯­éŸ³å¯¹è¯æ§åˆ¶</h3>
        <div id="recordStatus" class="status disconnected">æœªå½•éŸ³</div>
        <div class="controls">
            <button id="startBtn" onclick="startRecording()" disabled>ğŸ¤ å¼€å§‹å¯¹è¯</button>
            <button id="stopBtn" onclick="stopRecording()" disabled>â¹ï¸ åœæ­¢å½•éŸ³</button>
        </div>
        <p style="text-align: center; color: #6c757d; margin-top: 15px;">
            ğŸ’¡ ç‚¹å‡»"å¼€å§‹å¯¹è¯"åè¯´è¯ï¼Œè¯´å®Œè¯åä¼šè‡ªåŠ¨åœæ­¢å½•éŸ³ï¼Œéœ€è¦æ‰‹åŠ¨ç‚¹å‡»æ‰èƒ½å†æ¬¡å½•éŸ³
        </p>
    </div>

    <div class="container">
        <h3>ğŸ“Š å¯¹è¯ç»Ÿè®¡</h3>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="asrCount">0</div>
                <div class="stat-label">è¯­éŸ³è¯†åˆ«æ¬¡æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="aiReplyCount">0</div>
                <div class="stat-label">AIå›å¤æ¬¡æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="audioCount">0</div>
                <div class="stat-label">éŸ³é¢‘æ’­æ”¾æ¬¡æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="sessionDuration">00:00</div>
                <div class="stat-label">ä¼šè¯æ—¶é•¿</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h3>ğŸ’¬ å¯¹è¯è®°å½•</h3>
        <div class="results-container">
            <div class="result-panel">
                <h4>ğŸ¯ è¯­éŸ³è¯†åˆ«ç»“æœ (ASR)</h4>
                <div id="asrResults">ç­‰å¾…è¯­éŸ³è¾“å…¥...</div>
            </div>
            <div class="result-panel">
                <h4>ğŸ¤– AIå›å¤ & ğŸ”Š è¯­éŸ³æ’­æ”¾</h4>
                <div id="aiResults">ç­‰å¾…AIå›å¤...</div>
            </div>
        </div>
        <div class="controls" style="margin-top: 20px;">
            <button class="clear-btn" onclick="clearResults()">ğŸ—‘ï¸ æ¸…ç©ºè®°å½•</button>
            <button onclick="exportResults()">ğŸ“¥ å¯¼å‡ºè®°å½•</button>
        </div>
    </div>

    <script>
        let websocket = null;
        let isRecording = false;
        let currentSessionId = null;
        let audioBuffer = new Float32Array(0);
        let sessionStartTime = null;
        let sessionTimer = null;

        // è¯­éŸ³æ´»åŠ¨æ£€æµ‹ç›¸å…³å˜é‡ - ä¼˜åŒ–ä¸ºæ›´ä¸¥æ ¼çš„æ£€æµ‹
        let silenceCount = 0;
        let speechCount = 0;
        const maxSilenceFrames = 15; // è¿ç»­é™éŸ³å¸§æ•°é˜ˆå€¼ï¼ˆ15å¸§ï¼Œçº¦0.6ç§’å°±å‘é€ï¼‰
        const minSpeechFrames = 5;   // æœ€å°è¯­éŸ³å¸§æ•°é˜ˆå€¼ï¼ˆ5å¸§ï¼Œçº¦0.2ç§’ç¡®è®¤æ˜¯è¯­éŸ³ï¼‰
        let hasDetectedSpeech = false; // æ˜¯å¦æ£€æµ‹åˆ°è¿‡è¯­éŸ³
        let autoStopTimer = null;       // è‡ªåŠ¨åœæ­¢è®¡æ—¶å™¨
        let recordedAudioData = [];     // å­˜å‚¨å®Œæ•´å½•éŸ³æ•°æ®ï¼Œä¸€æ¬¡æ€§å‘é€

        // ç»Ÿè®¡æ•°æ®
        let stats = {
            asrCount: 0,
            aiReplyCount: 0,
            audioCount: 0
        };

        // WebSocketè¿æ¥
        function connectWebSocket() {
            const appId = document.getElementById('appIdInput').value || '123';
            const wsUrl = document.getElementById('wsUrlInput').value;
            const fullWsUrl = `${wsUrl}?appId=${appId}`;

            websocket = new WebSocket(fullWsUrl);

            websocket.onopen = function (event) {
                updateStatus('wsStatus', 'connected', `âœ… å·²è¿æ¥åˆ°æœåŠ¡ (AppID: ${appId})`);
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;
                document.getElementById('startBtn').disabled = false;

                currentSessionId = generateSessionId();
                sessionStartTime = new Date();
                startSessionTimer();

                addLog('ğŸ”— WebSocketè¿æ¥å·²å»ºç«‹');
                addLog(`ğŸ“‹ ä¼šè¯ID: ${currentSessionId}`);
                addLog(`ğŸ†” åº”ç”¨ID: ${appId}`);
            };

            websocket.onmessage = function (event) {
                console.log('ğŸ“¨ WebSocketåŸå§‹æ¶ˆæ¯:', {
                    dataType: typeof event.data,
                    dataLength: event.data instanceof ArrayBuffer ? event.data.byteLength : event.data.length,
                    timestamp: new Date().toISOString()
                });
                
                if (event.data instanceof ArrayBuffer) {
                    // å¤„ç†äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®
                    handleBinaryAudioMessage(event.data);
                } else {
                    // å¤„ç†æ–‡æœ¬æ¶ˆæ¯
                    handleWebSocketMessage(event.data);
                }
            };

            websocket.onclose = function (event) {
                updateStatus('wsStatus', 'disconnected', 'âŒ è¿æ¥å·²æ–­å¼€');
                updateStatus('recordStatus', 'disconnected', 'æœªå½•éŸ³');
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = true;

                stopSessionTimer();
                addLog('âŒ WebSocketè¿æ¥å·²å…³é—­');
            };

            websocket.onerror = function (error) {
                console.error('WebSocketé”™è¯¯:', error);
                updateStatus('wsStatus', 'disconnected', 'âŒ è¿æ¥é”™è¯¯');
                addLog('âŒ WebSocketè¿æ¥é”™è¯¯');
            };
        }

        // å¤„ç†äºŒè¿›åˆ¶éŸ³é¢‘æ¶ˆæ¯
        function handleBinaryAudioMessage(arrayBuffer) {
            const timestamp = new Date().toLocaleTimeString();
            
            console.log('ğŸ”Š æ”¶åˆ°äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®:', {
                timestamp: timestamp,
                byteLength: arrayBuffer.byteLength,
                type: 'ArrayBuffer'
            });

            // å°†ArrayBufferè½¬æ¢ä¸ºBase64ç”¨äºæ’­æ”¾
            const uint8Array = new Uint8Array(arrayBuffer);
            let binaryString = '';
            for (let i = 0; i < uint8Array.length; i++) {
                binaryString += String.fromCharCode(uint8Array[i]);
            }
            const audioBase64 = btoa(binaryString);
            
            console.log('ğŸµ éŸ³é¢‘æ•°æ®è½¬æ¢å®Œæˆ:', {
                originalBytes: arrayBuffer.byteLength,
                base64Length: audioBase64.length
            });

            addAudioPlayer(audioBase64, timestamp);
            stats.audioCount++;
            updateStats();
        }

        // å¤„ç†WebSocketæ–‡æœ¬æ¶ˆæ¯
        function handleWebSocketMessage(message) {
            const timestamp = new Date().toLocaleTimeString();

            // ç±»å‹æ£€æŸ¥å’Œè½¬æ¢
            if (typeof message !== 'string') {
                console.warn('âš ï¸ æ”¶åˆ°éå­—ç¬¦ä¸²æ¶ˆæ¯ï¼Œå°è¯•è½¬æ¢:', {
                    type: typeof message,
                    constructor: message.constructor.name,
                    message: message
                });
                
                // å¦‚æœæ˜¯ArrayBufferï¼Œè½¬ä¸ºäºŒè¿›åˆ¶å¤„ç†
                if (message instanceof ArrayBuffer) {
                    handleBinaryAudioMessage(message);
                    return;
                }
                
                // å°è¯•è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                try {
                    message = String(message);
                } catch (e) {
                    console.error('âŒ æ— æ³•è½¬æ¢æ¶ˆæ¯ä¸ºå­—ç¬¦ä¸²:', e);
                    return;
                }
            }

            // æ·»åŠ è¯¦ç»†çš„æ¶ˆæ¯è°ƒè¯•ä¿¡æ¯
            console.log('ğŸ” æ”¶åˆ°WebSocketæ–‡æœ¬æ¶ˆæ¯:', {
                timestamp: timestamp,
                messageType: message.startsWith('REPLY:') ? 'AIå›å¤' : 'ASRè¯†åˆ«',
                messageLength: message.length,
                messagePreview: message.substring(0, 50) + (message.length > 50 ? '...' : '')
            });

            if (message.startsWith('REPLY:')) {
                // AIå›å¤æ–‡æœ¬
                const replyText = message.substring(6);
                console.log('ğŸ“ å¤„ç†AIå›å¤:', replyText);
                addAIReply(replyText, timestamp);
                stats.aiReplyCount++;
                updateStats();
            } else {
                // ASRè¯†åˆ«æ–‡æœ¬
                console.log('ğŸ¤ å¤„ç†ASRè¯†åˆ«:', message);
                addASRResult(message, timestamp);
                stats.asrCount++;
                updateStats();
            }
        }

        // æ·»åŠ ASRè¯†åˆ«ç»“æœ
        function addASRResult(text, timestamp) {
            const asrResults = document.getElementById('asrResults');
            const resultDiv = document.createElement('div');
            resultDiv.className = 'asr-result';
            resultDiv.innerHTML = `
                <div class="timestamp">ğŸ• ${timestamp}</div>
                <div>ğŸ‘¤ ç”¨æˆ·è¯´: "${text}"</div>
            `;
            asrResults.appendChild(resultDiv);
            asrResults.scrollTop = asrResults.scrollHeight;
        }

        // æ·»åŠ AIå›å¤
        function addAIReply(text, timestamp) {
            const aiResults = document.getElementById('aiResults');
            const replyDiv = document.createElement('div');
            replyDiv.className = 'ai-reply';
            replyDiv.innerHTML = `
                <div class="timestamp">ğŸ• ${timestamp}</div>
                <div>ğŸ¤– AIå›å¤: "${text}"</div>
            `;
            aiResults.appendChild(replyDiv);
            aiResults.scrollTop = aiResults.scrollHeight;
        }

        // æ·»åŠ éŸ³é¢‘æ’­æ”¾å™¨
        function addAudioPlayer(audioBase64, timestamp) {
            console.log('ğŸµ å¼€å§‹å¤„ç†éŸ³é¢‘æ’­æ”¾å™¨:', {
                timestamp: timestamp,
                base64Length: audioBase64.length
            });

            const aiResults = document.getElementById('aiResults');
            const audioDiv = document.createElement('div');
            audioDiv.className = 'audio-item';

            try {
                // éªŒè¯Base64æ•°æ®
                if (!audioBase64 || audioBase64.length === 0) {
                    throw new Error('éŸ³é¢‘æ•°æ®ä¸ºç©º');
                }

                console.log('âœ… Base64æ•°æ®éªŒè¯é€šè¿‡');

                // è§£ç Base64éŸ³é¢‘æ•°æ®
                const audioData = atob(audioBase64);
                const audioArray = new Uint8Array(audioData.length);
                for (let i = 0; i < audioData.length; i++) {
                    audioArray[i] = audioData.charCodeAt(i);
                }

                console.log('ğŸ”¢ éŸ³é¢‘è§£ç å®Œæˆ:', {
                    originalBase64Length: audioBase64.length,
                    decodedDataLength: audioData.length,
                    audioArrayLength: audioArray.length,
                    firstFewBytes: Array.from(audioArray.slice(0, 10))
                });

                // åˆ›å»ºBlobå’ŒURLï¼Œå°è¯•å¤šç§éŸ³é¢‘æ ¼å¼
                const audioBlob = new Blob([audioArray], { type: 'audio/mpeg' });
                const audioUrl = URL.createObjectURL(audioBlob);

                console.log('ğŸŒ éŸ³é¢‘URLåˆ›å»ºæˆåŠŸ:', audioUrl);

                audioDiv.innerHTML = `
                    <div>
                        <div class="timestamp">ğŸ• ${timestamp}</div>
                        <div class="audio-controls">
                            ğŸ”Š TTSè¯­éŸ³ (${audioArray.length} bytes):
                            <audio controls preload="metadata" style="margin: 0 10px;">
                                <source src="${audioUrl}" type="audio/mpeg">
                                <source src="${audioUrl}" type="audio/mp3">
                                <source src="${audioUrl}" type="audio/wav">
                                æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾
                            </audio>
                            <button onclick="playAudio('${audioUrl}')" style="padding: 4px 8px; font-size: 12px;">â–¶ï¸ æ’­æ”¾</button>
                            <button onclick="downloadAudio('${audioUrl}', '${timestamp}')" style="padding: 4px 8px; font-size: 12px;">ğŸ’¾ ä¸‹è½½</button>
                        </div>
                    </div>
                `;

                // è‡ªåŠ¨æ’­æ”¾ï¼ˆå¦‚æœæµè§ˆå™¨å…è®¸ï¼‰
                const audio = audioDiv.querySelector('audio');

                // æ·»åŠ è¯¦ç»†çš„éŸ³é¢‘äº‹ä»¶ç›‘å¬
                audio.addEventListener('loadstart', () => {
                    console.log('ğŸµ éŸ³é¢‘å¼€å§‹åŠ è½½');
                });

                audio.addEventListener('loadedmetadata', () => {
                    console.log('ğŸ“Š éŸ³é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆ:', {
                        duration: audio.duration,
                        readyState: audio.readyState
                    });
                });

                audio.addEventListener('loadeddata', () => {
                    console.log('âœ… éŸ³é¢‘æ•°æ®åŠ è½½å®Œæˆï¼Œå°è¯•è‡ªåŠ¨æ’­æ”¾');
                    audio.play().then(() => {
                        console.log('ğŸ‰ éŸ³é¢‘è‡ªåŠ¨æ’­æ”¾æˆåŠŸ');
                    }).catch(e => {
                        console.log('âš ï¸ è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œéœ€è¦ç”¨æˆ·æ‰‹åŠ¨æ’­æ”¾:', e.message);
                    });
                });

                audio.addEventListener('canplay', () => {
                    console.log('â–¶ï¸ éŸ³é¢‘å¯ä»¥å¼€å§‹æ’­æ”¾');
                });

                audio.addEventListener('play', () => {
                    console.log('ğŸµ éŸ³é¢‘å¼€å§‹æ’­æ”¾');
                });

                audio.addEventListener('ended', () => {
                    console.log('ğŸ éŸ³é¢‘æ’­æ”¾ç»“æŸ');
                });

                audio.addEventListener('error', (e) => {
                    console.error('âŒ éŸ³é¢‘æ’­æ”¾é”™è¯¯:', {
                        error: e,
                        audioError: audio.error,
                        networkState: audio.networkState,
                        readyState: audio.readyState
                    });
                    audioDiv.innerHTML += '<div style="color: red;">âŒ éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒæˆ–æ•°æ®æŸå</div>';
                });

            } catch (error) {
                console.error('éŸ³é¢‘è§£ç å¤±è´¥:', error);
                audioDiv.innerHTML = `
                    <div class="timestamp">ğŸ• ${timestamp}</div>
                    <div style="color: red;">âŒ éŸ³é¢‘è§£ç å¤±è´¥: ${error.message}</div>
                    <div style="font-size: 12px; color: #666;">Base64é•¿åº¦: ${audioBase64 ? audioBase64.length : 0}</div>
                `;
            }

            aiResults.appendChild(audioDiv);
            aiResults.scrollTop = aiResults.scrollHeight;
        }

        // æ’­æ”¾éŸ³é¢‘
        function playAudio(audioUrl) {
            const audio = new Audio(audioUrl);
            audio.volume = 0.8; // è®¾ç½®éŸ³é‡
            audio.play().catch(e => {
                console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', e);
                alert('éŸ³é¢‘æ’­æ”¾å¤±è´¥: ' + e.message + '\nè¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®æˆ–éŸ³é¢‘æ ¼å¼');
            });
        }

        // ä¸‹è½½éŸ³é¢‘
        function downloadAudio(audioUrl, timestamp) {
            const a = document.createElement('a');
            a.href = audioUrl;
            a.download = `tts-audio-${timestamp.replace(/:/g, '-')}.mp3`;
            a.click();
        }

        // æ–­å¼€WebSocketè¿æ¥
        function disconnectWebSocket() {
            if (websocket) {
                websocket.close();
            }
        }

        // å¼€å§‹å½•éŸ³
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,      // å›å£°æ¶ˆé™¤
                        noiseSuppression: true,      // å™ªéŸ³æŠ‘åˆ¶
                        autoGainControl: true,       // è‡ªåŠ¨å¢ç›Šæ§åˆ¶
                        googEchoCancellation: true,  // Googleå›å£°æ¶ˆé™¤
                        googAutoGainControl: true,   // Googleè‡ªåŠ¨å¢ç›Š
                        googNoiseSuppression: true,  // Googleå™ªéŸ³æŠ‘åˆ¶
                        googHighpassFilter: true,    // é«˜é€šæ»¤æ³¢å™¨
                        googTypingNoiseDetection: true, // æ‰“å­—å™ªéŸ³æ£€æµ‹
                        googAudioMirroring: false,   // ç¦ç”¨éŸ³é¢‘é•œåƒ
                        latency: 0.01,              // ä½å»¶è¿Ÿ
                        volume: 1.0                 // æœ€å¤§éŸ³é‡
                    }
                });

                const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });

                const source = audioContext.createMediaStreamSource(stream);
                const processor = audioContext.createScriptProcessor(2048, 1, 1);

                audioBuffer = new Float32Array(0);
                recordedAudioData = []; // é‡ç½®å½•éŸ³æ•°æ®ç¼“å­˜

                processor.onaudioprocess = function (event) {
                    if (!isRecording) return;

                    const inputBuffer = event.inputBuffer;
                    const inputData = inputBuffer.getChannelData(0);

                    // å…ˆè¿›è¡ŒéŸ³é¢‘é¢„å¤„ç†ï¼šé«˜é€šæ»¤æ³¢å»é™¤ä½é¢‘å™ªéŸ³
                    const filteredData = highPassFilter(inputData, 80); // 80Hzé«˜é€šæ»¤æ³¢

                    // è¯­éŸ³æ´»åŠ¨æ£€æµ‹ï¼šè®¡ç®—éŸ³é¢‘èƒ½é‡ï¼ˆä½¿ç”¨æ»¤æ³¢åçš„æ•°æ®ï¼‰
                    let sum = 0;
                    for (let i = 0; i < filteredData.length; i++) {
                        sum += filteredData[i] * filteredData[i];
                    }
                    const rms = Math.sqrt(sum / filteredData.length);

                    // è·å–é…ç½®å‚æ•°
                    const vadEnabled = document.getElementById('vadEnabledInput').checked;
                    const silenceThreshold = parseFloat(document.getElementById('silenceThresholdInput').value) || 0.05;

                    // å°†æ‰€æœ‰éŸ³é¢‘æ•°æ®å­˜å‚¨åˆ°ç¼“å­˜ä¸­ï¼ˆæ— è®ºæ˜¯å¦æ£€æµ‹åˆ°è¯­éŸ³ï¼‰
                    const newBuffer = new Float32Array(audioBuffer.length + filteredData.length);
                    newBuffer.set(audioBuffer);
                    newBuffer.set(filteredData, audioBuffer.length);
                    audioBuffer = newBuffer;

                    // å¦‚æœç¦ç”¨è¯­éŸ³æ£€æµ‹ï¼Œç»§ç»­å½•éŸ³ä½†ä¸å®æ—¶å‘é€
                    if (!vadEnabled) {
                        console.log('è¯­éŸ³æ£€æµ‹å·²ç¦ç”¨ï¼Œç»§ç»­å½•éŸ³ï¼ŒRMS:', rms.toFixed(4));
                        return;
                    }

                    // è¯­éŸ³æ´»åŠ¨æ£€æµ‹é€»è¾‘
                    if (rms < silenceThreshold) {
                        silenceCount++;
                        speechCount = 0;

                        // å¦‚æœä¹‹å‰æ£€æµ‹åˆ°è¿‡è¯­éŸ³ï¼Œç°åœ¨è¿ç»­é™éŸ³è¶…è¿‡é˜ˆå€¼ï¼Œè‡ªåŠ¨åœæ­¢å½•éŸ³
                        if (hasDetectedSpeech && silenceCount > maxSilenceFrames) {
                            console.log('ğŸ”‡ æ£€æµ‹åˆ°è¯­éŸ³ç»“æŸï¼Œå‡†å¤‡è‡ªåŠ¨åœæ­¢å½•éŸ³ï¼Œæ€»æ—¶é•¿:', (audioBuffer.length / 16000).toFixed(2), 'ç§’');
                            autoStopRecording();
                            return;
                        }

                        console.log('ğŸ”‡ é™éŸ³å¸§:', silenceCount, '/', maxSilenceFrames, 'RMS:', rms.toFixed(4));
                    } else {
                        speechCount++;
                        silenceCount = 0;

                        // éœ€è¦è¾¾åˆ°æœ€å°è¯­éŸ³å¸§æ•°æ‰æ ‡è®°ä¸ºæ£€æµ‹åˆ°è¯­éŸ³
                        if (speechCount >= minSpeechFrames && !hasDetectedSpeech) {
                            hasDetectedSpeech = true;
                            console.log('ğŸ¤ æ£€æµ‹åˆ°æœ‰æ•ˆè¯­éŸ³å¼€å§‹ï¼ŒRMS:', rms.toFixed(4));
                        }

                        if (hasDetectedSpeech) {
                            console.log('ğŸ¤ è¯­éŸ³è¿›è¡Œä¸­ï¼ŒRMS:', rms.toFixed(4));
                        }
                    }
                };

                source.connect(processor);
                processor.connect(audioContext.destination);

                window.audioContext = audioContext;
                window.audioProcessor = processor;
                window.audioStream = stream;

                isRecording = true;

                // é‡ç½®è¯­éŸ³æ£€æµ‹çŠ¶æ€
                hasDetectedSpeech = false;
                silenceCount = 0;
                speechCount = 0;
                audioBuffer = new Float32Array(0);
                recordedAudioData = [];

                updateStatus('recordStatus', 'recording', 'ğŸ™ï¸ æ­£åœ¨å½•éŸ³ï¼Œè¯·è¯´è¯...ï¼ˆé™éŸ³0.6ç§’åè‡ªåŠ¨å‘é€ï¼‰');
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;

                addLog('ğŸ™ï¸ å¼€å§‹å½•éŸ³ï¼Œé«˜è´¨é‡éŸ³é¢‘é‡‡é›†å·²å¯ç”¨');
                addLog('ğŸ”§ å™ªéŸ³æŠ‘åˆ¶: å¼€å¯ | å›å£°æ¶ˆé™¤: å¼€å¯ | è‡ªåŠ¨å¢ç›Š: å¼€å¯');
                addLog('â±ï¸ é™éŸ³æ£€æµ‹: 0.6ç§’é™éŸ³åè‡ªåŠ¨å‘é€');
            } catch (error) {
                console.error('å½•éŸ³å¤±è´¥:', error);
                addLog('âŒ æ— æ³•è®¿é—®éº¦å…‹é£: ' + error.message);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
            }
        }

        // é«˜é€šæ»¤æ³¢å™¨å‡½æ•°ï¼ˆå»é™¤ä½é¢‘å™ªéŸ³ï¼‰
        function highPassFilter(inputData, cutoffFreq) {
            const sampleRate = 16000;
            const RC = 1.0 / (cutoffFreq * 2 * Math.PI);
            const dt = 1.0 / sampleRate;
            const alpha = RC / (RC + dt);
            
            const filteredData = new Float32Array(inputData.length);
            let prevInput = 0;
            let prevOutput = 0;
            
            for (let i = 0; i < inputData.length; i++) {
                filteredData[i] = alpha * (prevOutput + inputData[i] - prevInput);
                prevInput = inputData[i];
                prevOutput = filteredData[i];
            }
            
            return filteredData;
        }

        // è‡ªåŠ¨åœæ­¢å½•éŸ³ï¼ˆæ£€æµ‹åˆ°è¯­éŸ³ç»“æŸåè°ƒç”¨ï¼‰
        function autoStopRecording() {
            console.log('ğŸ”‡ è‡ªåŠ¨åœæ­¢å½•éŸ³ï¼Œæ€»å½•éŸ³æ—¶é•¿:', (audioBuffer.length / 16000).toFixed(2), 'ç§’');
            stopRecording();
            sendCompleteAudio();
        }

        // å‘é€å®Œæ•´çš„å½•éŸ³æ•°æ®
        function sendCompleteAudio() {
            if (audioBuffer.length > 0 && websocket && websocket.readyState === WebSocket.OPEN) {
                // å¯¹å®Œæ•´éŸ³é¢‘è¿›è¡Œé™å™ªå¤„ç†
                const denoisedAudio = applyNoiseReduction(audioBuffer);
                
                // è½¬æ¢ä¸ºPCMæ ¼å¼
                const pcmData = floatTo16BitPCM(denoisedAudio);
                
                console.log('ğŸ“¤ å‘é€å®Œæ•´å½•éŸ³æ•°æ®:', {
                    åŸå§‹é•¿åº¦: audioBuffer.length,
                    å¤„ç†åé•¿åº¦: denoisedAudio.length,
                    å­—èŠ‚æ•°: pcmData.byteLength,
                    æ—¶é•¿: (denoisedAudio.length / 16000).toFixed(2) + 'ç§’'
                });

                // åˆ†å—å‘é€å¤§éŸ³é¢‘æ–‡ä»¶
                const chunkSize = 8192; // 8KB chunks
                const totalChunks = Math.ceil(pcmData.byteLength / chunkSize);
                
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, pcmData.byteLength);
                    const chunk = pcmData.slice(start, end);
                    
                    websocket.send(chunk);
                    console.log(`ğŸ“¤ å‘é€éŸ³é¢‘å— ${i + 1}/${totalChunks}, å¤§å°: ${chunk.byteLength} å­—èŠ‚`);
                }

                // å‘é€ç»“æŸæ ‡è®°
                websocket.send('END');
                console.log('ğŸ“¤ å‘é€å½•éŸ³ç»“æŸæ ‡è®°');
            }
        }

        // ç®€å•çš„é™å™ªå¤„ç†
        function applyNoiseReduction(audioData) {
            // è®¡ç®—éŸ³é¢‘çš„å¹³å‡èƒ½é‡
            let totalEnergy = 0;
            for (let i = 0; i < audioData.length; i++) {
                totalEnergy += audioData[i] * audioData[i];
            }
            const avgEnergy = totalEnergy / audioData.length;
            const noiseThreshold = avgEnergy * 0.1; // å™ªéŸ³é˜ˆå€¼è®¾ä¸ºå¹³å‡èƒ½é‡çš„10%

            // åº”ç”¨å™ªéŸ³é—¨é™
            const denoisedData = new Float32Array(audioData.length);
            for (let i = 0; i < audioData.length; i++) {
                const energy = audioData[i] * audioData[i];
                if (energy > noiseThreshold) {
                    denoisedData[i] = audioData[i];
                } else {
                    denoisedData[i] = audioData[i] * 0.1; // é™ä½å™ªéŸ³éƒ¨åˆ†çš„éŸ³é‡
                }
            }

            return denoisedData;
        }
        function floatTo16BitPCM(float32Array) {
            const buffer = new ArrayBuffer(float32Array.length * 2);
            const view = new DataView(buffer);
            let offset = 0;
            for (let i = 0; i < float32Array.length; i++, offset += 2) {
                let s = Math.max(-1, Math.min(1, float32Array[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
            return buffer;
        }

        // åœæ­¢å½•éŸ³
        function stopRecording() {
            if (!isRecording) return;
            isRecording = false;

            updateStatus('recordStatus', 'disconnected', 'å½•éŸ³å·²åœæ­¢ï¼Œæ­£åœ¨å¤„ç†...');
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;

            // æ¸…ç†éŸ³é¢‘èµ„æº
            if (window.audioContext) {
                window.audioContext.close();
            }
            if (window.audioProcessor) {
                window.audioProcessor.disconnect();
            }
            if (window.audioStream) {
                window.audioStream.getTracks().forEach(track => track.stop());
            }

            // å¦‚æœæ˜¯ç”¨æˆ·ä¸»åŠ¨åœæ­¢ï¼Œä¹Ÿå‘é€å®Œæ•´å½•éŸ³æ•°æ®
            if (audioBuffer.length > 0) {
                sendCompleteAudio();
            }

            // é‡ç½®çŠ¶æ€
            setTimeout(() => {
                updateStatus('recordStatus', 'disconnected', 'æœªå½•éŸ³');
            }, 2000);
        }


        // å·¥å…·å‡½æ•°
        function updateStatus(elementId, status, message) {
            const statusDiv = document.getElementById(elementId);
            statusDiv.className = `status ${status}`;
            statusDiv.textContent = message;
        }

        function addLog(message) {
            console.log(message);
        }

        function clearResults() {
            document.getElementById('asrResults').innerHTML = 'ç­‰å¾…è¯­éŸ³è¾“å…¥...';
            document.getElementById('aiResults').innerHTML = 'ç­‰å¾…AIå›å¤...';

            // é‡ç½®ç»Ÿè®¡
            stats = { asrCount: 0, aiReplyCount: 0, audioCount: 0 };
            updateStats();

            addLog('ğŸ—‘ï¸ å·²æ¸…ç©ºæ‰€æœ‰è®°å½•');
        }

        function updateStats() {
            document.getElementById('asrCount').textContent = stats.asrCount;
            document.getElementById('aiReplyCount').textContent = stats.aiReplyCount;
            document.getElementById('audioCount').textContent = stats.audioCount;

            // åœ¨æ§åˆ¶å°è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
            console.log('ğŸ“Š ç»Ÿè®¡æ›´æ–°:', {
                ASRè¯†åˆ«æ¬¡æ•°: stats.asrCount,
                AIå›å¤æ¬¡æ•°: stats.aiReplyCount,
                éŸ³é¢‘æ’­æ”¾æ¬¡æ•°: stats.audioCount
            });
        }

        function startSessionTimer() {
            sessionTimer = setInterval(() => {
                if (sessionStartTime) {
                    const elapsed = Math.floor((new Date() - sessionStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('sessionDuration').textContent =
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        function stopSessionTimer() {
            if (sessionTimer) {
                clearInterval(sessionTimer);
                sessionTimer = null;
            }
        }

        function exportResults() {
            const asrResults = document.getElementById('asrResults').innerText;
            const aiResults = document.getElementById('aiResults').innerText;
            const exportData = `AIè¯­éŸ³å¯¹è¯è®°å½•\n\n=== ASRè¯†åˆ«ç»“æœ ===\n${asrResults}\n\n=== AIå›å¤è®°å½• ===\n${aiResults}`;

            const blob = new Blob([exportData], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai-conversation-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function generateSessionId() {
            return 'session_' + Math.random().toString(36).substr(2, 9);
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        window.onload = function () {
            console.log('ğŸš€ é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–è°ƒè¯•æ¨¡å¼');
            console.log('ğŸ”§ æµè§ˆå™¨ä¿¡æ¯:', {
                userAgent: navigator.userAgent,
                audioSupport: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
                webSocketSupport: !!window.WebSocket,
                audioContextSupport: !!(window.AudioContext || window.webkitAudioContext)
            });

            addLog('ğŸš€ AIè¯­éŸ³å¯¹è¯æµ‹è¯•é¡µé¢åŠ è½½å®Œæˆ');
            addLog('ğŸ“‹ ä½¿ç”¨è¯´æ˜ï¼š');
            addLog('1. é…ç½®åº”ç”¨IDå’ŒWebSocketåœ°å€');
            addLog('2. ç‚¹å‡»"è¿æ¥æœåŠ¡"å»ºç«‹è¿æ¥');
            addLog('3. ç‚¹å‡»"å¼€å§‹å¯¹è¯"è¿›è¡Œè¯­éŸ³è¾“å…¥');
            addLog('4. ç³»ç»Ÿå°†è‡ªåŠ¨è¿›è¡Œè¯­éŸ³è¯†åˆ«ã€AIå›å¤å’Œè¯­éŸ³åˆæˆ');
            addLog('5. æŸ¥çœ‹å¯¹è¯è®°å½•å’Œç»Ÿè®¡ä¿¡æ¯');
            addLog('ğŸ” è°ƒè¯•æ¨¡å¼å·²å¯ç”¨ï¼Œè¯·æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯');
        };

        // é¡µé¢å…³é—­æ—¶æ¸…ç†èµ„æº
        window.onbeforeunload = function () {
            if (isRecording) {
                stopRecording();
            }
            if (websocket) {
                websocket.close();
            }
            stopSessionTimer();
        };
    </script>
</body>

</html>