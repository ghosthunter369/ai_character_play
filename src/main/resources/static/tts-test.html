<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è¯­éŸ³å¯¹è¯æµ‹è¯• - ASR + AI + TTS</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin: 15px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.2em;
            margin: 10px 0;
            opacity: 0.9;
        }

        button {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            margin: 8px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .config-section {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .config-section label {
            font-weight: 600;
            color: #495057;
        }

        .config-section input {
            padding: 8px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .config-section input:focus {
            outline: none;
            border-color: #007bff;
        }

        .results-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .results-container {
                grid-template-columns: 1fr;
            }
        }

        .result-panel {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            padding: 20px;
            border-radius: 8px;
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
        }

        .result-panel h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 1.1em;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 8px;
        }

        .asr-result {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px;
            margin: 8px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .ai-reply {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            padding: 10px;
            margin: 8px 0;
            border-radius: 4px;
        }

        .audio-item {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
            padding: 10px;
            margin: 8px 0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
            text-align: center;
            transition: all 0.3s ease;
        }

        .status.connected {
            background: linear-gradient(45deg, #d4edda, #c3e6cb);
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .status.disconnected {
            background: linear-gradient(45deg, #f8d7da, #f5c6cb);
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        .status.recording {
            background: linear-gradient(45deg, #fff3cd, #ffeaa7);
            color: #856404;
            border: 2px solid #ffeaa7;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }

            100% {
                transform: scale(1);
            }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .audio-controls audio {
            max-width: 200px;
        }

        .timestamp {
            font-size: 0.8em;
            color: #6c757d;
            margin-bottom: 5px;
        }

        .clear-btn {
            background: linear-gradient(45deg, #dc3545, #c82333);
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
        }

        .clear-btn:hover {
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.4);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #dee2e6;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #007bff;
        }

        .stat-label {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }
    </style>
</head>

<body>
<div class="header">
    <h1>ğŸ¤– AI è¯­éŸ³å¯¹è¯æµ‹è¯•</h1>
    <p>ASR è¯­éŸ³è¯†åˆ« â†’ AI æ™ºèƒ½å›å¤ â†’ TTS è¯­éŸ³åˆæˆ</p>
</div>

<div class="container">
    <h3>âš™ï¸ è¿æ¥é…ç½®</h3>
    <div class="config-section">
        <label for="appIdInput">åº”ç”¨ID:</label>
        <input type="text" id="appIdInput" value="1970673379841900546" placeholder="è¾“å…¥åº”ç”¨ID">
        <label for="wsUrlInput">WebSocketåœ°å€:</label>
        <input type="text" id="wsUrlInput" value="ws://localhost:8123/api/ws/audio" placeholder="WebSocket URL">
    </div>
    <div class="config-section">
        <label for="silenceThresholdInput">é™éŸ³é˜ˆå€¼:</label>
        <input type="number" id="silenceThresholdInput" value="0.015" step="0.001" min="0" max="1" placeholder="0.015"
               style="width: 80px;" title="éŸ³é¢‘èƒ½é‡ä½äºæ­¤å€¼è§†ä¸ºé™éŸ³">
        
        <label for="speechThresholdInput">è¯­éŸ³é˜ˆå€¼:</label>
        <input type="number" id="speechThresholdInput" value="0.03" step="0.001" min="0" max="1" placeholder="0.03"
               style="width: 80px;" title="éŸ³é¢‘èƒ½é‡é«˜äºæ­¤å€¼è§†ä¸ºæœ‰æ•ˆè¯­éŸ³">
        
        <label for="vadEnabledInput">å¯ç”¨æ™ºèƒ½å£°æ§:</label>
        <input type="checkbox" id="vadEnabledInput" checked>
    </div>
    <div class="config-section">
        <label for="minSpeechDurationInput">æœ€çŸ­è¯­éŸ³æ—¶é•¿(ms):</label>
        <input type="number" id="minSpeechDurationInput" value="500" step="50" min="100" max="2000" 
               style="width: 80px;" title="æ£€æµ‹åˆ°è¯­éŸ³åéœ€è¦æŒç»­çš„æœ€çŸ­æ—¶é—´">
        
        <label for="maxSilenceDurationInput">æœ€é•¿é™éŸ³æ—¶é•¿(ms):</label>
        <input type="number" id="maxSilenceDurationInput" value="2000" step="100" min="500" max="5000" 
               style="width: 80px;" title="è¯­éŸ³ç»“æŸåç­‰å¾…çš„æœ€é•¿é™éŸ³æ—¶é—´">
        
        <span style="font-size: 12px; color: #666;">ï¼ˆæ™ºèƒ½æ£€æµ‹è¯­éŸ³å¼€å§‹å’Œç»“æŸï¼‰</span>
    </div>
    <div class="vad-indicator" style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
        <span>éŸ³é‡:</span>
        <div class="volume-bar" style="width: 200px; height: 20px; background: #e9ecef; border-radius: 10px; overflow: hidden; position: relative;">
            <div class="volume-fill" id="volumeFill" style="height: 100%; background: linear-gradient(90deg, #28a745, #ffc107, #dc3545); width: 0%; transition: width 0.1s ease;"></div>
        </div>
        <div class="speech-status silence" id="speechStatus" style="padding: 5px 10px; border-radius: 15px; font-size: 12px; font-weight: bold; min-width: 60px; text-align: center; background: #6c757d; color: white;">é™éŸ³</div>
        <span id="vadInfo" style="font-size: 12px; color: #666;">ç­‰å¾…å¼€å§‹å½•éŸ³</span>
    </div>
    <div id="wsStatus" class="status disconnected">æœªè¿æ¥</div>
    <div class="controls">
        <button id="connectBtn" onclick="connectWebSocket()">ğŸ”— è¿æ¥æœåŠ¡</button>
        <button id="disconnectBtn" onclick="disconnectWebSocket()" disabled>âŒ æ–­å¼€è¿æ¥</button>
    </div>
</div>

<div class="container">
    <h3>ğŸ™ï¸ è¯­éŸ³å¯¹è¯æ§åˆ¶</h3>
    <div id="recordStatus" class="status disconnected">æœªå½•éŸ³</div>
    <div class="controls">
        <button id="startBtn" onclick="startRecording()" disabled>ğŸ¤ å¼€å§‹å¯¹è¯</button>
        <button id="stopBtn" onclick="stopRecording()" disabled>â¹ï¸ åœæ­¢å½•éŸ³</button>
    </div>
    <p style="text-align: center; color: #6c757d; margin-top: 15px;">
        ğŸ’¡ ç‚¹å‡»"å¼€å§‹å¯¹è¯"åè¯´è¯ï¼Œè¯´å®Œè¯åä¼šè‡ªåŠ¨åœæ­¢å½•éŸ³ï¼Œéœ€è¦æ‰‹åŠ¨ç‚¹å‡»æ‰èƒ½å†æ¬¡å½•éŸ³
    </p>
</div>

<div class="container">
    <h3>ğŸ“Š å¯¹è¯ç»Ÿè®¡</h3>
    <div class="stats">
        <div class="stat-item">
            <div class="stat-value" id="asrCount">0</div>
            <div class="stat-label">è¯­éŸ³è¯†åˆ«æ¬¡æ•°</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="aiReplyCount">0</div>
            <div class="stat-label">AIå›å¤æ¬¡æ•°</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="audioCount">0</div>
            <div class="stat-label">éŸ³é¢‘æ’­æ”¾æ¬¡æ•°</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="sessionDuration">00:00</div>
            <div class="stat-label">ä¼šè¯æ—¶é•¿</div>
        </div>
    </div>
</div>

<div class="container">
    <h3>ğŸ’¬ å¯¹è¯è®°å½•</h3>
    <div class="results-container">
        <div class="result-panel">
            <h4>ğŸ¯ è¯­éŸ³è¯†åˆ«ç»“æœ (ASR)</h4>
            <div id="asrResults">ç­‰å¾…è¯­éŸ³è¾“å…¥...</div>
        </div>
        <div class="result-panel">
            <h4>ğŸ¤– AIå›å¤ & ğŸ”Š è¯­éŸ³æ’­æ”¾</h4>
            <div id="aiResults">ç­‰å¾…AIå›å¤...</div>
        </div>
    </div>
    <div class="controls" style="margin-top: 20px;">
        <button class="clear-btn" onclick="clearResults()">ğŸ—‘ï¸ æ¸…ç©ºè®°å½•</button>
        <button onclick="exportResults()">ğŸ“¥ å¯¼å‡ºè®°å½•</button>
    </div>
</div>

<script>
    let websocket = null;
    let isRecording = false;
    let currentSessionId = null;
    let audioBuffer = new Float32Array(0);
    let sessionStartTime = null;
    let sessionTimer = null;

    // æ™ºèƒ½è¯­éŸ³æ´»åŠ¨æ£€æµ‹ç›¸å…³å˜é‡
    let vadState = 'silence'; // 'silence', 'speech', 'waiting'
    let speechStartTime = null;
    let silenceStartTime = null;
    let currentVolume = 0;
    let smoothedVolume = 0;
    let hasDetectedSpeech = false;
    let autoStopTimer = null;

    // ç»Ÿè®¡æ•°æ®
    let stats = {
        asrCount: 0,
        aiReplyCount: 0,
        audioCount: 0
    };

    // WebSocketè¿æ¥
    function connectWebSocket() {
        const appId = document.getElementById('appIdInput').value || '123';
        const wsUrl = document.getElementById('wsUrlInput').value;
        const fullWsUrl = `${wsUrl}?appId=${appId}`;

        websocket = new WebSocket(fullWsUrl);

        websocket.onopen = function (event) {
            updateStatus('wsStatus', 'connected', `âœ… å·²è¿æ¥åˆ°æœåŠ¡ (AppID: ${appId})`);
            document.getElementById('connectBtn').disabled = true;
            document.getElementById('disconnectBtn').disabled = false;
            document.getElementById('startBtn').disabled = false;

            currentSessionId = generateSessionId();
            sessionStartTime = new Date();
            startSessionTimer();

            addLog('ğŸ”— WebSocketè¿æ¥å·²å»ºç«‹');
            addLog(`ğŸ“‹ ä¼šè¯ID: ${currentSessionId}`);
            addLog(`ğŸ†” åº”ç”¨ID: ${appId}`);
        };

        websocket.onmessage = function (event) {
            console.log('ğŸ“¨ WebSocketåŸå§‹æ¶ˆæ¯:', {
                dataType: typeof event.data,
                dataLength: event.data instanceof ArrayBuffer ? event.data.byteLength : event.data.length,
                timestamp: new Date().toISOString(),
                isBinary: event.data instanceof ArrayBuffer
            });
            handleWebSocketMessage(event.data);
        };

        websocket.onclose = function (event) {
            updateStatus('wsStatus', 'disconnected', 'âŒ è¿æ¥å·²æ–­å¼€');
            updateStatus('recordStatus', 'disconnected', 'æœªå½•éŸ³');
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;

            stopSessionTimer();
            addLog('âŒ WebSocketè¿æ¥å·²å…³é—­');
        };

        websocket.onerror = function (error) {
            console.error('WebSocketé”™è¯¯:', error);
            updateStatus('wsStatus', 'disconnected', 'âŒ è¿æ¥é”™è¯¯');
            addLog('âŒ WebSocketè¿æ¥é”™è¯¯');
        };
    }

    // å¤„ç†WebSocketæ¶ˆæ¯
    function handleWebSocketMessage(message) {
        const timestamp = new Date().toLocaleTimeString();

        // æ£€æŸ¥æ¶ˆæ¯ç±»å‹
        if (message instanceof ArrayBuffer) {
            // å¤„ç†äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®
            console.log('ğŸ”Š æ”¶åˆ°äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®:', {
                timestamp: timestamp,
                messageType: 'äºŒè¿›åˆ¶éŸ³é¢‘',
                byteLength: message.byteLength
            });
            handleBinaryAudio(message, timestamp);
            return;
        }

        // å¤„ç†Blobç±»å‹æ¶ˆæ¯
        if (message instanceof Blob) {
            console.log('ğŸ”Š æ”¶åˆ°BlobéŸ³é¢‘æ•°æ®:', {
                timestamp: timestamp,
                messageType: 'BlobéŸ³é¢‘',
                size: message.size,
                type: message.type
            });
            handleBlobAudio(message, timestamp);
            return;
        }

        // ç¡®ä¿æ¶ˆæ¯æ˜¯å­—ç¬¦ä¸²ç±»å‹
        if (typeof message !== 'string') {
            console.warn('âš ï¸ æ”¶åˆ°éå­—ç¬¦ä¸²æ¶ˆæ¯:', typeof message, message);
            return;
        }

        // æ·»åŠ è¯¦ç»†çš„æ¶ˆæ¯è°ƒè¯•ä¿¡æ¯
        console.log('ğŸ” æ”¶åˆ°WebSocketæ¶ˆæ¯:', {
            timestamp: timestamp,
            messageType: message.startsWith('REPLY:') ? 'AIå›å¤' :
                message.startsWith('AUDIO:') ? 'TTSéŸ³é¢‘' : 'ASRè¯†åˆ«',
            messageLength: message.length,
            messagePreview: message.substring(0, 50) + (message.length > 50 ? '...' : '')
        });

        if (message.startsWith('REPLY:')) {
            // AIå›å¤æ–‡æœ¬
            const replyText = message.substring(6);
            console.log('ğŸ“ å¤„ç†AIå›å¤:', replyText);
            addAIReply(replyText, timestamp);
            stats.aiReplyCount++;
            updateStats();
        } else if (message.startsWith('AUDIO:')) {
            // TTSéŸ³é¢‘æ•°æ® (Base64æ ¼å¼) - æµå¼æ’­æ”¾
            const audioBase64 = message.substring(6);
            console.log('ğŸ”Š å¤„ç†TTSéŸ³é¢‘æ•°æ® (Base64æµå¼):', {
                base64Length: audioBase64.length,
                estimatedBytes: Math.floor(audioBase64.length * 3 / 4),
                base64Preview: audioBase64.substring(0, 50) + '...'
            });
            
            // å°†Base64è½¬æ¢ä¸ºArrayBufferå¹¶åŠ å…¥æµå¼æ’­æ”¾é˜Ÿåˆ—
            try {
                const audioData = atob(audioBase64);
                const audioArray = new Uint8Array(audioData.length);
                for (let i = 0; i < audioData.length; i++) {
                    audioArray[i] = audioData.charCodeAt(i);
                }
                
                console.log('âœ… Base64è§£ç æˆåŠŸï¼ŒåŠ å…¥æµå¼æ’­æ”¾é˜Ÿåˆ—');
                addToAudioQueue(audioArray.buffer, timestamp);
                
            } catch (error) {
                console.error('âŒ Base64è§£ç å¤±è´¥:', error);
                // é™çº§åˆ°åŸæœ‰å¤„ç†æ–¹å¼
                addAudioPlayer(audioBase64, timestamp);
            }
        } else {
            // ASRè¯†åˆ«æ–‡æœ¬
            console.log('ğŸ¤ å¤„ç†ASRè¯†åˆ«:', message);
            addASRResult(message, timestamp);
            stats.asrCount++;
            updateStats();
        }
    }

    // æµå¼éŸ³é¢‘æ’­æ”¾ç›¸å…³å˜é‡
    let streamingAudio = null;
    let audioQueue = [];
    let isPlaying = false;
    let audioContext = null;
    let audioSource = null;

    // å¤„ç†BlobéŸ³é¢‘æ•°æ®ï¼ˆæµå¼æ’­æ”¾ï¼‰
    function handleBlobAudio(blob, timestamp) {
        console.log('ğŸµ å¼€å§‹å¤„ç†BlobéŸ³é¢‘æ•°æ®:', {
            timestamp: timestamp,
            size: blob.size,
            type: blob.type
        });

        // å°†Blobè½¬æ¢ä¸ºArrayBuffer
        blob.arrayBuffer().then(arrayBuffer => {
            console.log('âœ… Blobè½¬ArrayBufferæˆåŠŸ:', arrayBuffer.byteLength);
            
            // æ·»åŠ åˆ°éŸ³é¢‘é˜Ÿåˆ—è¿›è¡Œæµå¼æ’­æ”¾
            addToAudioQueue(arrayBuffer, timestamp);
            
        }).catch(error => {
            console.error('âŒ Blobè½¬ArrayBufferå¤±è´¥:', error);
        });
    }

    // æ·»åŠ éŸ³é¢‘æ•°æ®åˆ°æ’­æ”¾é˜Ÿåˆ—
    function addToAudioQueue(audioData, timestamp) {
        audioQueue.push({
            data: audioData,
            timestamp: timestamp
        });
        
        console.log('ğŸ“ éŸ³é¢‘æ•°æ®å·²åŠ å…¥é˜Ÿåˆ—ï¼Œé˜Ÿåˆ—é•¿åº¦:', audioQueue.length);
        
        // å¦‚æœå½“å‰æ²¡æœ‰æ’­æ”¾ï¼Œå¼€å§‹æ’­æ”¾
        if (!isPlaying) {
            playNextAudioInQueue();
        }
    }

    // æ’­æ”¾é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªéŸ³é¢‘
    function playNextAudioInQueue() {
        if (audioQueue.length === 0) {
            isPlaying = false;
            console.log('ğŸ éŸ³é¢‘é˜Ÿåˆ—æ’­æ”¾å®Œæˆ');
            return;
        }

        isPlaying = true;
        const audioItem = audioQueue.shift();
        
        console.log('â–¶ï¸ å¼€å§‹æ’­æ”¾éŸ³é¢‘ç‰‡æ®µ:', {
            timestamp: audioItem.timestamp,
            dataLength: audioItem.data.byteLength,
            remainingQueue: audioQueue.length
        });

        // åˆ›å»ºéŸ³é¢‘æ’­æ”¾å™¨
        playAudioStream(audioItem.data, audioItem.timestamp);
    }

    // æµå¼æ’­æ”¾éŸ³é¢‘æ•°æ®
    function playAudioStream(audioData, timestamp) {
        try {
            // åˆ›å»ºBlobå’ŒURL
            const audioBlob = new Blob([audioData], { type: 'audio/mpeg' });
            const audioUrl = URL.createObjectURL(audioBlob);

            // åˆ›å»ºAudioå…ƒç´ è¿›è¡Œæ’­æ”¾
            const audio = new Audio(audioUrl);
            audio.volume = 0.8;
            
            // æ·»åŠ åˆ°é¡µé¢æ˜¾ç¤º
            addStreamingAudioToUI(audioUrl, timestamp, audioData.byteLength);

            // æ’­æ”¾äº‹ä»¶ç›‘å¬
            audio.addEventListener('loadeddata', () => {
                console.log('ğŸµ éŸ³é¢‘æ•°æ®åŠ è½½å®Œæˆï¼Œå¼€å§‹æ’­æ”¾');
                audio.play().then(() => {
                    console.log('âœ… éŸ³é¢‘æ’­æ”¾æˆåŠŸ');
                }).catch(e => {
                    console.error('âŒ éŸ³é¢‘æ’­æ”¾å¤±è´¥:', e);
                    // æ’­æ”¾å¤±è´¥æ—¶ç»§ç»­æ’­æ”¾ä¸‹ä¸€ä¸ª
                    playNextAudioInQueue();
                });
            });

            audio.addEventListener('ended', () => {
                console.log('ğŸ éŸ³é¢‘ç‰‡æ®µæ’­æ”¾ç»“æŸ');
                URL.revokeObjectURL(audioUrl);
                // æ’­æ”¾ä¸‹ä¸€ä¸ªéŸ³é¢‘
                setTimeout(() => playNextAudioInQueue(), 100);
            });

            audio.addEventListener('error', (e) => {
                console.error('âŒ éŸ³é¢‘æ’­æ”¾é”™è¯¯:', e);
                URL.revokeObjectURL(audioUrl);
                // å‡ºé”™æ—¶ç»§ç»­æ’­æ”¾ä¸‹ä¸€ä¸ª
                playNextAudioInQueue();
            });

            stats.audioCount++;
            updateStats();

        } catch (error) {
            console.error('âŒ æµå¼éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
            // å‡ºé”™æ—¶ç»§ç»­æ’­æ”¾ä¸‹ä¸€ä¸ª
            playNextAudioInQueue();
        }
    }

    // æ·»åŠ æµå¼éŸ³é¢‘åˆ°UIæ˜¾ç¤º
    function addStreamingAudioToUI(audioUrl, timestamp, dataLength) {
        const aiResults = document.getElementById('aiResults');
        const audioDiv = document.createElement('div');
        audioDiv.className = 'audio-item';

        const audioId = 'stream_audio_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        audioDiv.innerHTML = `
            <div>
                <div class="timestamp">ğŸ• ${timestamp}</div>
                <div class="audio-controls">
                    ğŸ”Š æµå¼TTS (${formatBytes(dataLength)}):
                    <audio id="${audioId}" controls preload="metadata" style="margin: 0 10px;">
                        <source src="${audioUrl}" type="audio/mpeg">
                        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾
                    </audio>
                    <button onclick="playStreamAudio('${audioId}')" style="padding: 4px 8px; font-size: 12px;">â–¶ï¸ é‡æ’­</button>
                    <span style="font-size: 12px; color: #28a745;">â— æµå¼æ’­æ”¾ä¸­</span>
                </div>
            </div>
        `;

        aiResults.appendChild(audioDiv);
        aiResults.scrollTop = aiResults.scrollHeight;
    }

    // é‡æ’­æµå¼éŸ³é¢‘
    function playStreamAudio(audioId) {
        const audio = document.getElementById(audioId);
        if (audio) {
            audio.currentTime = 0;
            audio.play().catch(e => {
                console.error('é‡æ’­å¤±è´¥:', e);
            });
        }
    }

    // å¤„ç†äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®
    function handleBinaryAudio(arrayBuffer, timestamp) {
        console.log('ğŸµ å¼€å§‹å¤„ç†äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®:', {
            timestamp: timestamp,
            byteLength: arrayBuffer.byteLength,
            firstBytes: new Uint8Array(arrayBuffer.slice(0, 16))
        });

        const aiResults = document.getElementById('aiResults');
        const audioDiv = document.createElement('div');
        audioDiv.className = 'audio-item';

        try {
            // æ£€æµ‹éŸ³é¢‘æ ¼å¼
            const uint8Array = new Uint8Array(arrayBuffer);
            let audioType = 'audio/mpeg'; // é»˜è®¤MP3
            let fileExtension = 'mp3';
            
            // æ£€æµ‹æ–‡ä»¶å¤´æ¥ç¡®å®šéŸ³é¢‘æ ¼å¼
            if (uint8Array.length >= 4) {
                const header = Array.from(uint8Array.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join('');
                console.log('ğŸ” éŸ³é¢‘æ–‡ä»¶å¤´:', header);
                
                if (header.startsWith('fff') || header.startsWith('fffb')) {
                    audioType = 'audio/mpeg';
                    fileExtension = 'mp3';
                    console.log('ğŸ“„ æ£€æµ‹åˆ°MP3æ ¼å¼');
                } else if (header === '52494646') { // RIFF
                    audioType = 'audio/wav';
                    fileExtension = 'wav';
                    console.log('ğŸ“„ æ£€æµ‹åˆ°WAVæ ¼å¼');
                } else if (header.startsWith('4f676753')) { // OggS
                    audioType = 'audio/ogg';
                    fileExtension = 'ogg';
                    console.log('ğŸ“„ æ£€æµ‹åˆ°OGGæ ¼å¼');
                } else {
                    console.log('ğŸ“„ æœªçŸ¥æ ¼å¼ï¼Œä½¿ç”¨é»˜è®¤MP3');
                }
            }

            // åˆ›å»ºBlobå’ŒURL
            const audioBlob = new Blob([arrayBuffer], { type: audioType });
            const audioUrl = URL.createObjectURL(audioBlob);

            console.log('ğŸŒ äºŒè¿›åˆ¶éŸ³é¢‘URLåˆ›å»ºæˆåŠŸ:', {
                url: audioUrl,
                type: audioType,
                size: arrayBuffer.byteLength
            });

            // åˆ›å»ºå”¯ä¸€IDç”¨äºéŸ³é¢‘æ§åˆ¶
            const audioId = 'audio_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            audioDiv.innerHTML = `
                <div>
                    <div class="timestamp">ğŸ• ${timestamp}</div>
                    <div class="audio-controls">
                        ğŸ”Š TTSè¯­éŸ³ (äºŒè¿›åˆ¶${fileExtension.toUpperCase()}, ${formatBytes(arrayBuffer.byteLength)}):
                        <audio id="${audioId}" controls preload="metadata" style="margin: 0 10px;">
                            <source src="${audioUrl}" type="${audioType}">
                            <source src="${audioUrl}" type="audio/mpeg">
                            <source src="${audioUrl}" type="audio/wav">
                            æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾
                        </audio>
                        <button onclick="playBinaryAudio('${audioId}')" style="padding: 4px 8px; font-size: 12px;">â–¶ï¸ æ’­æ”¾</button>
                        <button onclick="downloadBinaryAudio('${audioUrl}', '${timestamp}', '${fileExtension}')" style="padding: 4px 8px; font-size: 12px;">ğŸ’¾ ä¸‹è½½</button>
                        <button onclick="analyzeBinaryAudio('${audioId}')" style="padding: 4px 8px; font-size: 12px;">ğŸ“Š åˆ†æ</button>
                    </div>
                    <div id="${audioId}_info" style="font-size: 12px; color: #666; margin-top: 5px;"></div>
                </div>
            `;

            // è·å–éŸ³é¢‘å…ƒç´ å¹¶æ·»åŠ äº‹ä»¶ç›‘å¬
            const audio = audioDiv.querySelector('audio');
            
            // è¯¦ç»†çš„éŸ³é¢‘äº‹ä»¶ç›‘å¬
            audio.addEventListener('loadstart', () => {
                console.log('ğŸµ äºŒè¿›åˆ¶éŸ³é¢‘å¼€å§‹åŠ è½½');
                updateAudioInfo(audioId, 'æ­£åœ¨åŠ è½½...');
            });

            audio.addEventListener('loadedmetadata', () => {
                console.log('ğŸ“Š äºŒè¿›åˆ¶éŸ³é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆ:', {
                    duration: audio.duration,
                    readyState: audio.readyState,
                    networkState: audio.networkState
                });
                updateAudioInfo(audioId, `æ—¶é•¿: ${formatDuration(audio.duration)}, çŠ¶æ€: å·²åŠ è½½`);
            });

            audio.addEventListener('loadeddata', () => {
                console.log('âœ… äºŒè¿›åˆ¶éŸ³é¢‘æ•°æ®åŠ è½½å®Œæˆï¼Œå°è¯•è‡ªåŠ¨æ’­æ”¾');
                updateAudioInfo(audioId, `æ—¶é•¿: ${formatDuration(audio.duration)}, çŠ¶æ€: å¯æ’­æ”¾`);
                
                // è‡ªåŠ¨æ’­æ”¾
                audio.play().then(() => {
                    console.log('ğŸ‰ äºŒè¿›åˆ¶éŸ³é¢‘è‡ªåŠ¨æ’­æ”¾æˆåŠŸ');
                    updateAudioInfo(audioId, `æ—¶é•¿: ${formatDuration(audio.duration)}, çŠ¶æ€: æ­£åœ¨æ’­æ”¾`);
                }).catch(e => {
                    console.log('âš ï¸ è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œéœ€è¦ç”¨æˆ·æ‰‹åŠ¨æ’­æ”¾:', e.message);
                    updateAudioInfo(audioId, `æ—¶é•¿: ${formatDuration(audio.duration)}, çŠ¶æ€: ç­‰å¾…æ’­æ”¾`);
                });
            });

            audio.addEventListener('canplay', () => {
                console.log('â–¶ï¸ äºŒè¿›åˆ¶éŸ³é¢‘å¯ä»¥å¼€å§‹æ’­æ”¾');
            });

            audio.addEventListener('play', () => {
                console.log('ğŸµ äºŒè¿›åˆ¶éŸ³é¢‘å¼€å§‹æ’­æ”¾');
                updateAudioInfo(audioId, `æ—¶é•¿: ${formatDuration(audio.duration)}, çŠ¶æ€: æ­£åœ¨æ’­æ”¾`);
            });

            audio.addEventListener('pause', () => {
                console.log('â¸ï¸ äºŒè¿›åˆ¶éŸ³é¢‘æš‚åœæ’­æ”¾');
                updateAudioInfo(audioId, `æ—¶é•¿: ${formatDuration(audio.duration)}, çŠ¶æ€: å·²æš‚åœ`);
            });

            audio.addEventListener('ended', () => {
                console.log('ğŸ äºŒè¿›åˆ¶éŸ³é¢‘æ’­æ”¾ç»“æŸ');
                updateAudioInfo(audioId, `æ—¶é•¿: ${formatDuration(audio.duration)}, çŠ¶æ€: æ’­æ”¾å®Œæˆ`);
            });

            audio.addEventListener('error', (e) => {
                console.error('âŒ äºŒè¿›åˆ¶éŸ³é¢‘æ’­æ”¾é”™è¯¯:', {
                    error: e,
                    audioError: audio.error,
                    networkState: audio.networkState,
                    readyState: audio.readyState
                });
                updateAudioInfo(audioId, 'âŒ æ’­æ”¾é”™è¯¯');
                audioDiv.innerHTML += '<div style="color: red; margin-top: 5px;">âŒ éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒæˆ–æ•°æ®æŸå</div>';
            });

            stats.audioCount++;
            updateStats();

        } catch (error) {
            console.error('äºŒè¿›åˆ¶éŸ³é¢‘å¤„ç†å¤±è´¥:', error);
            audioDiv.innerHTML = `
                <div class="timestamp">ğŸ• ${timestamp}</div>
                <div style="color: red;">âŒ äºŒè¿›åˆ¶éŸ³é¢‘å¤„ç†å¤±è´¥: ${error.message}</div>
                <div style="font-size: 12px; color: #666;">æ•°æ®é•¿åº¦: ${formatBytes(arrayBuffer.byteLength)}</div>
            `;
        }

        aiResults.appendChild(audioDiv);
        aiResults.scrollTop = aiResults.scrollHeight;
    }

    // æ·»åŠ ASRè¯†åˆ«ç»“æœ
    function addASRResult(text, timestamp) {
        const asrResults = document.getElementById('asrResults');
        const resultDiv = document.createElement('div');
        resultDiv.className = 'asr-result';
        resultDiv.innerHTML = `
                <div class="timestamp">ğŸ• ${timestamp}</div>
                <div>ğŸ‘¤ ç”¨æˆ·è¯´: "${text}"</div>
            `;
        asrResults.appendChild(resultDiv);
        asrResults.scrollTop = asrResults.scrollHeight;
    }

    // æ·»åŠ AIå›å¤
    function addAIReply(text, timestamp) {
        const aiResults = document.getElementById('aiResults');
        const replyDiv = document.createElement('div');
        replyDiv.className = 'ai-reply';
        replyDiv.innerHTML = `
                <div class="timestamp">ğŸ• ${timestamp}</div>
                <div>ğŸ¤– AIå›å¤: "${text}"</div>
            `;
        aiResults.appendChild(replyDiv);
        aiResults.scrollTop = aiResults.scrollHeight;
    }

    // æ·»åŠ éŸ³é¢‘æ’­æ”¾å™¨
    function addAudioPlayer(audioBase64, timestamp) {
        console.log('ğŸµ å¼€å§‹å¤„ç†éŸ³é¢‘æ’­æ”¾å™¨:', {
            timestamp: timestamp,
            base64Length: audioBase64.length
        });

        const aiResults = document.getElementById('aiResults');
        const audioDiv = document.createElement('div');
        audioDiv.className = 'audio-item';

        try {
            // éªŒè¯Base64æ•°æ®
            if (!audioBase64 || audioBase64.length === 0) {
                throw new Error('éŸ³é¢‘æ•°æ®ä¸ºç©º');
            }

            console.log('âœ… Base64æ•°æ®éªŒè¯é€šè¿‡');

            // è§£ç Base64éŸ³é¢‘æ•°æ®
            const audioData = atob(audioBase64);
            const audioArray = new Uint8Array(audioData.length);
            for (let i = 0; i < audioData.length; i++) {
                audioArray[i] = audioData.charCodeAt(i);
            }

            console.log('ğŸ”¢ éŸ³é¢‘è§£ç å®Œæˆ:', {
                originalBase64Length: audioBase64.length,
                decodedDataLength: audioData.length,
                audioArrayLength: audioArray.length,
                firstFewBytes: Array.from(audioArray.slice(0, 10))
            });

            // åˆ›å»ºBlobå’ŒURLï¼Œå°è¯•å¤šç§éŸ³é¢‘æ ¼å¼
            const audioBlob = new Blob([audioArray], { type: 'audio/mpeg' });
            const audioUrl = URL.createObjectURL(audioBlob);

            console.log('ğŸŒ éŸ³é¢‘URLåˆ›å»ºæˆåŠŸ:', audioUrl);

            audioDiv.innerHTML = `
                    <div>
                        <div class="timestamp">ğŸ• ${timestamp}</div>
                        <div class="audio-controls">
                            ğŸ”Š TTSè¯­éŸ³ (${audioArray.length} bytes):
                            <audio controls preload="metadata" style="margin: 0 10px;">
                                <source src="${audioUrl}" type="audio/mpeg">
                                <source src="${audioUrl}" type="audio/mp3">
                                <source src="${audioUrl}" type="audio/wav">
                                æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾
                            </audio>
                            <button onclick="playAudio('${audioUrl}')" style="padding: 4px 8px; font-size: 12px;">â–¶ï¸ æ’­æ”¾</button>
                            <button onclick="downloadAudio('${audioUrl}', '${timestamp}')" style="padding: 4px 8px; font-size: 12px;">ğŸ’¾ ä¸‹è½½</button>
                        </div>
                    </div>
                `;

            // è‡ªåŠ¨æ’­æ”¾ï¼ˆå¦‚æœæµè§ˆå™¨å…è®¸ï¼‰
            const audio = audioDiv.querySelector('audio');

            // æ·»åŠ è¯¦ç»†çš„éŸ³é¢‘äº‹ä»¶ç›‘å¬
            audio.addEventListener('loadstart', () => {
                console.log('ğŸµ éŸ³é¢‘å¼€å§‹åŠ è½½');
            });

            audio.addEventListener('loadedmetadata', () => {
                console.log('ğŸ“Š éŸ³é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆ:', {
                    duration: audio.duration,
                    readyState: audio.readyState
                });
            });

            audio.addEventListener('loadeddata', () => {
                console.log('âœ… éŸ³é¢‘æ•°æ®åŠ è½½å®Œæˆï¼Œå°è¯•è‡ªåŠ¨æ’­æ”¾');
                audio.play().then(() => {
                    console.log('ğŸ‰ éŸ³é¢‘è‡ªåŠ¨æ’­æ”¾æˆåŠŸ');
                }).catch(e => {
                    console.log('âš ï¸ è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œéœ€è¦ç”¨æˆ·æ‰‹åŠ¨æ’­æ”¾:', e.message);
                });
            });

            audio.addEventListener('canplay', () => {
                console.log('â–¶ï¸ éŸ³é¢‘å¯ä»¥å¼€å§‹æ’­æ”¾');
            });

            audio.addEventListener('play', () => {
                console.log('ğŸµ éŸ³é¢‘å¼€å§‹æ’­æ”¾');
            });

            audio.addEventListener('ended', () => {
                console.log('ğŸ éŸ³é¢‘æ’­æ”¾ç»“æŸ');
            });

            audio.addEventListener('error', (e) => {
                console.error('âŒ éŸ³é¢‘æ’­æ”¾é”™è¯¯:', {
                    error: e,
                    audioError: audio.error,
                    networkState: audio.networkState,
                    readyState: audio.readyState
                });
                audioDiv.innerHTML += '<div style="color: red;">âŒ éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒæˆ–æ•°æ®æŸå</div>';
            });

        } catch (error) {
            console.error('éŸ³é¢‘è§£ç å¤±è´¥:', error);
            audioDiv.innerHTML = `
                    <div class="timestamp">ğŸ• ${timestamp}</div>
                    <div style="color: red;">âŒ éŸ³é¢‘è§£ç å¤±è´¥: ${error.message}</div>
                    <div style="font-size: 12px; color: #666;">Base64é•¿åº¦: ${audioBase64 ? audioBase64.length : 0}</div>
                `;
        }

        aiResults.appendChild(audioDiv);
        aiResults.scrollTop = aiResults.scrollHeight;
    }

    // æ’­æ”¾éŸ³é¢‘
    function playAudio(audioUrl) {
        const audio = new Audio(audioUrl);
        audio.volume = 0.8; // è®¾ç½®éŸ³é‡
        audio.play().catch(e => {
            console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', e);
            alert('éŸ³é¢‘æ’­æ”¾å¤±è´¥: ' + e.message + '\nè¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®æˆ–éŸ³é¢‘æ ¼å¼');
        });
    }

    // ä¸‹è½½éŸ³é¢‘
    function downloadAudio(audioUrl, timestamp) {
        const a = document.createElement('a');
        a.href = audioUrl;
        a.download = `tts-audio-${timestamp.replace(/:/g, '-')}.mp3`;
        a.click();
    }

    // æ–­å¼€WebSocketè¿æ¥
    function disconnectWebSocket() {
        if (websocket) {
            websocket.close();
        }
    }

    // å¼€å§‹å½•éŸ³
    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    sampleRate: 16000,
                    channelCount: 1,
                    echoCancellation: true,
                    noiseSuppression: true
                }
            });

            const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 16000
            });

            const source = audioContext.createMediaStreamSource(stream);
            const processor = audioContext.createScriptProcessor(2048, 1, 1);

            audioBuffer = new Float32Array(0);
            const frameSize = 1280;

            processor.onaudioprocess = function (event) {
                if (!isRecording) return;

                const inputBuffer = event.inputBuffer;
                const inputData = inputBuffer.getChannelData(0);

                // æ™ºèƒ½è¯­éŸ³æ´»åŠ¨æ£€æµ‹
                const vadResult = processVAD(inputData);
                
                // æ›´æ–°éŸ³é‡æŒ‡ç¤ºå™¨
                updateVolumeIndicator(vadResult.volume, vadResult.status, vadResult.info);
                
                // å¦‚æœä¸åº”è¯¥å‘é€æ•°æ®ï¼Œè·³è¿‡
                if (!vadResult.shouldSend) {
                    return;
                }
                
                // å¦‚æœæ£€æµ‹åˆ°è¯­éŸ³ç»“æŸï¼Œè‡ªåŠ¨åœæ­¢å½•éŸ³
                if (vadResult.shouldStop) {
                    autoStopRecording();
                    return;
                }

                const newBuffer = new Float32Array(audioBuffer.length + inputData.length);
                newBuffer.set(audioBuffer);
                newBuffer.set(inputData, audioBuffer.length);
                audioBuffer = newBuffer;

                while (audioBuffer.length >= frameSize) {
                    const frameData = audioBuffer.slice(0, frameSize);
                    audioBuffer = audioBuffer.slice(frameSize);

                    const pcmData = new Int16Array(frameSize);
                    for (let i = 0; i < frameSize; i++) {
                        pcmData[i] = Math.max(-32768, Math.min(32767, Math.floor(frameData[i] * 32768)));
                    }

                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        websocket.send(pcmData.buffer);
                    }
                }
            };

            source.connect(processor);
            processor.connect(audioContext.destination);

            window.audioContext = audioContext;
            window.audioProcessor = processor;
            window.audioStream = stream;

            isRecording = true;

            // é‡ç½®æ™ºèƒ½è¯­éŸ³æ£€æµ‹çŠ¶æ€
            vadState = 'silence';
            speechStartTime = null;
            silenceStartTime = null;
            hasDetectedSpeech = false;
            currentVolume = 0;
            smoothedVolume = 0;

            updateStatus('recordStatus', 'recording', 'ğŸ™ï¸ æ­£åœ¨å½•éŸ³ï¼Œè¯·è¯´è¯...');
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;

            addLog('ğŸ™ï¸ å¼€å§‹å½•éŸ³ï¼Œç­‰å¾…è¯­éŸ³è¾“å…¥...');
        } catch (error) {
            console.error('å½•éŸ³å¤±è´¥:', error);
            addLog('âŒ æ— æ³•è®¿é—®éº¦å…‹é£: ' + error.message);
            alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
        }
    }

    // æ™ºèƒ½è¯­éŸ³æ´»åŠ¨æ£€æµ‹å¤„ç†å‡½æ•°
    function processVAD(inputData) {
        // è®¡ç®—éŸ³é¢‘èƒ½é‡ (RMS)
        let sum = 0;
        for (let i = 0; i < inputData.length; i++) {
            sum += inputData[i] * inputData[i];
        }
        currentVolume = Math.sqrt(sum / inputData.length);
        
        // è·å–é…ç½®å‚æ•°
        const vadEnabled = document.getElementById('vadEnabledInput').checked;
        const silenceThreshold = parseFloat(document.getElementById('silenceThresholdInput').value) || 0.015;
        const speechThreshold = parseFloat(document.getElementById('speechThresholdInput').value) || 0.03;
        const minSpeechDuration = parseInt(document.getElementById('minSpeechDurationInput').value) || 500;
        const maxSilenceDuration = parseInt(document.getElementById('maxSilenceDurationInput').value) || 2000;
        
        const currentTime = Date.now();
        let shouldSend = false;
        let shouldStop = false;
        let statusInfo = '';

        if (!vadEnabled) {
            // VADç¦ç”¨æ—¶ç›´æ¥å‘é€æ‰€æœ‰æ•°æ®
            return { 
                shouldSend: true, 
                shouldStop: false, 
                volume: currentVolume,
                status: 'speech',
                info: 'è¯­éŸ³æ£€æµ‹å·²ç¦ç”¨'
            };
        }

        // çŠ¶æ€æœºå¤„ç†
        switch (vadState) {
            case 'silence':
                if (currentVolume > speechThreshold) {
                    // æ£€æµ‹åˆ°è¯­éŸ³å¼€å§‹
                    vadState = 'speech';
                    speechStartTime = currentTime;
                    silenceStartTime = null;
                    hasDetectedSpeech = true;
                    
                    shouldSend = true;
                    statusInfo = 'æ£€æµ‹åˆ°è¯­éŸ³å¼€å§‹';
                    updateStatus('recordStatus', 'recording', 'ğŸ™ï¸ æ­£åœ¨å½•éŸ³ - æ£€æµ‹åˆ°è¯­éŸ³');
                } else {
                    // ç»§ç»­é™éŸ³
                    statusInfo = 'ç­‰å¾…è¯­éŸ³è¾“å…¥';
                }
                break;

            case 'speech':
                if (currentVolume > silenceThreshold) {
                    // ç»§ç»­è¯­éŸ³
                    shouldSend = true;
                    const speechDuration = currentTime - speechStartTime;
                    statusInfo = `è¯­éŸ³è¿›è¡Œä¸­ (${Math.round(speechDuration / 100) / 10}s)`;
                } else {
                    // æ£€æµ‹åˆ°é™éŸ³ï¼Œä½†éœ€è¦ç¡®è®¤æ˜¯å¦çœŸçš„ç»“æŸ
                    if (!silenceStartTime) {
                        silenceStartTime = currentTime;
                    }
                    
                    const speechDuration = currentTime - speechStartTime;
                    const silenceDuration = currentTime - silenceStartTime;
                    
                    if (speechDuration >= minSpeechDuration && 
                        silenceDuration >= maxSilenceDuration) {
                        // è¯­éŸ³ç»“æŸ
                        vadState = 'waiting';
                        shouldStop = true;
                        statusInfo = 'è¯­éŸ³ç»“æŸï¼Œå¤„ç†ä¸­...';
                        updateStatus('recordStatus', 'processing', 'ğŸ¤– è¯­éŸ³è¯†åˆ«å®Œæˆï¼Œç­‰å¾…AIå›å¤...');
                    } else {
                        // ç»§ç»­å‘é€ï¼Œå¯èƒ½æ˜¯çŸ­æš‚åœé¡¿
                        shouldSend = true;
                        statusInfo = `è¯­éŸ³ä¸­ (é™éŸ³ ${Math.round(silenceDuration / 100) / 10}s)`;
                    }
                }
                break;

            case 'waiting':
                // ç­‰å¾…çŠ¶æ€ï¼Œä¸å¤„ç†éŸ³é¢‘
                statusInfo = 'ç­‰å¾…AIå›å¤...';
                break;
        }

        return { 
            shouldSend, 
            shouldStop, 
            volume: currentVolume,
            status: vadState === 'silence' ? 'silence' : 
                   vadState === 'speech' ? 'speech' : 'waiting',
            info: statusInfo
        };
    }

    // æ›´æ–°éŸ³é‡æŒ‡ç¤ºå™¨
    function updateVolumeIndicator(volume, status, info) {
        const volumeFill = document.getElementById('volumeFill');
        const speechStatus = document.getElementById('speechStatus');
        const vadInfo = document.getElementById('vadInfo');

        // å¹³æ»‘éŸ³é‡æ˜¾ç¤º
        smoothedVolume = smoothedVolume * 0.8 + volume * 0.2;
        const volumePercent = Math.min(100, smoothedVolume * 1000); // æ”¾å¤§æ˜¾ç¤º
        volumeFill.style.width = volumePercent + '%';

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        if (status === 'silence') {
            speechStatus.style.background = '#6c757d';
            speechStatus.textContent = 'é™éŸ³';
        } else if (status === 'speech') {
            speechStatus.style.background = '#28a745';
            speechStatus.textContent = 'è¯­éŸ³';
        } else {
            speechStatus.style.background = '#ffc107';
            speechStatus.style.color = 'black';
            speechStatus.textContent = 'ç­‰å¾…';
        }
        
        vadInfo.textContent = info || '';
    }

    // è‡ªåŠ¨åœæ­¢å½•éŸ³ï¼ˆæ£€æµ‹åˆ°è¯­éŸ³ç»“æŸåè°ƒç”¨ï¼‰
    function autoStopRecording() {
        if (!isRecording) return;

        console.log('ğŸ¤– è‡ªåŠ¨åœæ­¢å½•éŸ³ï¼Œç­‰å¾…AIå›å¤...');

        // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´ç¡®ä¿æœ€åçš„éŸ³é¢‘æ•°æ®è¢«å¤„ç†
        setTimeout(() => {
            stopRecording();
            addLog('ğŸ¤– æ£€æµ‹åˆ°è¯­éŸ³ç»“æŸï¼Œè‡ªåŠ¨åœæ­¢å½•éŸ³');
        }, 200);
    }

    // åœæ­¢å½•éŸ³
    function stopRecording() {
        if (isRecording) {
            isRecording = false;

            // é‡ç½®æ™ºèƒ½è¯­éŸ³æ£€æµ‹çŠ¶æ€
            vadState = 'silence';
            speechStartTime = null;
            silenceStartTime = null;
            hasDetectedSpeech = false;
            currentVolume = 0;
            smoothedVolume = 0;

            // å‘é€å‰©ä½™éŸ³é¢‘æ•°æ®
            if (audioBuffer && audioBuffer.length > 0) {
                const pcmData = new Int16Array(audioBuffer.length);
                for (let i = 0; i < audioBuffer.length; i++) {
                    pcmData[i] = Math.max(-32768, Math.min(32767, Math.floor(audioBuffer[i] * 32768)));
                }
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    websocket.send(pcmData.buffer);
                }
            }

            audioBuffer = new Float32Array(0);

            // æ¸…ç†èµ„æº
            if (window.audioProcessor) {
                window.audioProcessor.disconnect();
                window.audioProcessor = null;
            }

            if (window.audioContext) {
                window.audioContext.close();
                window.audioContext = null;
            }

            if (window.audioStream) {
                window.audioStream.getTracks().forEach(track => track.stop());
                window.audioStream = null;
            }

            // å‘é€ç»“æŸä¿¡å·
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send('END');
            }

            updateStatus('recordStatus', 'disconnected', 'â¹ï¸ å½•éŸ³å·²åœæ­¢ï¼Œå¤„ç†ä¸­...');
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;

            addLog('â¹ï¸ å½•éŸ³ç»“æŸï¼Œç­‰å¾…AIå›å¤å’Œè¯­éŸ³åˆæˆ...');
        }
    }

    // å·¥å…·å‡½æ•°
    function updateStatus(elementId, status, message) {
        const statusDiv = document.getElementById(elementId);
        statusDiv.className = `status ${status}`;
        statusDiv.textContent = message;
    }

    function addLog(message) {
        console.log(message);
    }

    function clearResults() {
        document.getElementById('asrResults').innerHTML = 'ç­‰å¾…è¯­éŸ³è¾“å…¥...';
        document.getElementById('aiResults').innerHTML = 'ç­‰å¾…AIå›å¤...';

        // é‡ç½®ç»Ÿè®¡
        stats = { asrCount: 0, aiReplyCount: 0, audioCount: 0 };
        updateStats();

        addLog('ğŸ—‘ï¸ å·²æ¸…ç©ºæ‰€æœ‰è®°å½•');
    }

    function updateStats() {
        document.getElementById('asrCount').textContent = stats.asrCount;
        document.getElementById('aiReplyCount').textContent = stats.aiReplyCount;
        document.getElementById('audioCount').textContent = stats.audioCount;

        // åœ¨æ§åˆ¶å°è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
        console.log('ğŸ“Š ç»Ÿè®¡æ›´æ–°:', {
            ASRè¯†åˆ«æ¬¡æ•°: stats.asrCount,
            AIå›å¤æ¬¡æ•°: stats.aiReplyCount,
            éŸ³é¢‘æ’­æ”¾æ¬¡æ•°: stats.audioCount
        });
    }

    function startSessionTimer() {
        sessionTimer = setInterval(() => {
            if (sessionStartTime) {
                const elapsed = Math.floor((new Date() - sessionStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('sessionDuration').textContent =
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }, 1000);
    }

    function stopSessionTimer() {
        if (sessionTimer) {
            clearInterval(sessionTimer);
            sessionTimer = null;
        }
    }

    function exportResults() {
        const asrResults = document.getElementById('asrResults').innerText;
        const aiResults = document.getElementById('aiResults').innerText;
        const exportData = `AIè¯­éŸ³å¯¹è¯è®°å½•\n\n=== ASRè¯†åˆ«ç»“æœ ===\n${asrResults}\n\n=== AIå›å¤è®°å½• ===\n${aiResults}`;

        const blob = new Blob([exportData], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ai-conversation-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function generateSessionId() {
        return 'session_' + Math.random().toString(36).substr(2, 9);
    }

    // æ’­æ”¾äºŒè¿›åˆ¶éŸ³é¢‘
    function playBinaryAudio(audioId) {
        const audio = document.getElementById(audioId);
        if (audio) {
            audio.volume = 0.8;
            audio.currentTime = 0; // é‡æ–°å¼€å§‹æ’­æ”¾
            audio.play().catch(e => {
                console.error('äºŒè¿›åˆ¶éŸ³é¢‘æ’­æ”¾å¤±è´¥:', e);
                alert('éŸ³é¢‘æ’­æ”¾å¤±è´¥: ' + e.message + 'è¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®æˆ–éŸ³é¢‘æ ¼å¼');
            });
        }
    }

    // åˆ†æäºŒè¿›åˆ¶éŸ³é¢‘
    function analyzeBinaryAudio(audioId) {
        const audio = document.getElementById(audioId);
        if (audio) {
            const info = {
                æ—¶é•¿: formatDuration(audio.duration),
                å½“å‰æ—¶é—´: formatDuration(audio.currentTime),
                éŸ³é‡: Math.round(audio.volume * 100) + '%',
                æ’­æ”¾é€Ÿåº¦: audio.playbackRate + 'x',
                ç½‘ç»œçŠ¶æ€: getNetworkState(audio.networkState),
                å°±ç»ªçŠ¶æ€: getReadyState(audio.readyState),
                æ˜¯å¦æš‚åœ: audio.paused ? 'æ˜¯' : 'å¦',
                æ˜¯å¦ç»“æŸ: audio.ended ? 'æ˜¯' : 'å¦',
                æ˜¯å¦é™éŸ³: audio.muted ? 'æ˜¯' : 'å¦'
            };
            
            console.log('ğŸ“Š éŸ³é¢‘åˆ†æç»“æœ:', info);
            
            let infoText = 'ğŸ“Š éŸ³é¢‘ä¿¡æ¯:';
            for (const [key, value] of Object.entries(info)) {
                infoText += `${key}: ${value}
`;
            }
            
            alert(infoText);
        }
    }

    // ä¸‹è½½äºŒè¿›åˆ¶éŸ³é¢‘
    function downloadBinaryAudio(audioUrl, timestamp, extension) {
        const a = document.createElement('a');
        a.href = audioUrl;
        a.download = `tts-binary-${timestamp.replace(/:/g, '-')}.${extension}`;
        a.click();
    }

    // æ›´æ–°éŸ³é¢‘ä¿¡æ¯æ˜¾ç¤º
    function updateAudioInfo(audioId, info) {
        const infoDiv = document.getElementById(audioId + '_info');
        if (infoDiv) {
            infoDiv.textContent = info;
        }
    }

    // æ ¼å¼åŒ–å­—èŠ‚å¤§å°
    function formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // æ ¼å¼åŒ–æ—¶é•¿
    function formatDuration(seconds) {
        if (isNaN(seconds) || !isFinite(seconds)) return 'æœªçŸ¥';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // è·å–ç½‘ç»œçŠ¶æ€æè¿°
    function getNetworkState(state) {
        const states = {
            0: 'ç©ºé—²',
            1: 'åŠ è½½ä¸­',
            2: 'æ— æ•°æ®',
            3: 'æ— æº'
        };
        return states[state] || 'æœªçŸ¥';
    }

    // è·å–å°±ç»ªçŠ¶æ€æè¿°
    function getReadyState(state) {
        const states = {
            0: 'æ— ä¿¡æ¯',
            1: 'å…ƒæ•°æ®',
            2: 'å½“å‰æ•°æ®',
            3: 'æœªæ¥æ•°æ®',
            4: 'è¶³å¤Ÿæ•°æ®'
        };
        return states[state] || 'æœªçŸ¥';
    }

    // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
    window.onload = function () {
        console.log('ğŸš€ é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–è°ƒè¯•æ¨¡å¼');
        console.log('ğŸ”§ æµè§ˆå™¨ä¿¡æ¯:', {
            userAgent: navigator.userAgent,
            audioSupport: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
            webSocketSupport: !!window.WebSocket,
            audioContextSupport: !!(window.AudioContext || window.webkitAudioContext)
        });

        addLog('ğŸš€ AIè¯­éŸ³å¯¹è¯æµ‹è¯•é¡µé¢åŠ è½½å®Œæˆ');
        addLog('ğŸ“‹ ä½¿ç”¨è¯´æ˜ï¼š');
        addLog('1. é…ç½®åº”ç”¨IDå’ŒWebSocketåœ°å€');
        addLog('2. ç‚¹å‡»"è¿æ¥æœåŠ¡"å»ºç«‹è¿æ¥');
        addLog('3. ç‚¹å‡»"å¼€å§‹å¯¹è¯"è¿›è¡Œè¯­éŸ³è¾“å…¥');
        addLog('4. ç³»ç»Ÿå°†è‡ªåŠ¨è¿›è¡Œè¯­éŸ³è¯†åˆ«ã€AIå›å¤å’Œè¯­éŸ³åˆæˆ');
        addLog('5. æŸ¥çœ‹å¯¹è¯è®°å½•å’Œç»Ÿè®¡ä¿¡æ¯');
        addLog('ğŸ” è°ƒè¯•æ¨¡å¼å·²å¯ç”¨ï¼Œè¯·æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯');
    };

    // é¡µé¢å…³é—­æ—¶æ¸…ç†èµ„æº
    window.onbeforeunload = function () {
        if (isRecording) {
            stopRecording();
        }
        if (websocket) {
            websocket.close();
        }
        stopSessionTimer();
    };
</script>
</body>

</html>